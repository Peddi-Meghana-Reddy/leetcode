import heapq
class Solution:
    def minCost(self, grid: list[list[int]], k: int) -> int:
        m, n = len(grid), len(grid[0])
        INF = float('inf')
        dist = [[[INF] * (k + 1) for _ in range(n)] for _ in range(m)]
        dist[0][0][0] = 0
        cells = []
        for i in range(m):
            for j in range(n):
                cells.append((grid[i][j], i, j))
        cells.sort()
        used = [[False] * (m * n) for _ in range(k + 1)]
        ptr = [0] * (k + 1)
        pq = [(0, 0, 0, 0)] 
        directions = [(1, 0), (0, 1)]
        while pq:
            cost, r, c, t = heapq.heappop(pq)
            if cost > dist[r][c][t]:
                continue
            if r == m - 1 and c == n - 1:
                return cost
            for dr, dc in directions:
                nr, nc = r + dr, c + dc
                if 0 <= nr < m and 0 <= nc < n:
                    new_cost = cost + grid[nr][nc]
                    if new_cost < dist[nr][nc][t]:
                        dist[nr][nc][t] = new_cost
                        heapq.heappush(pq, (new_cost, nr, nc, t))
            if t < k:
                curr_val = grid[r][c]
                p = ptr[t + 1]
                while p < len(cells) and cells[p][0] <= curr_val:
                    _, i, j = cells[p]
                    idx = i * n + j
                    if not used[t + 1][idx] and cost < dist[i][j][t + 1]:
                        used[t + 1][idx] = True
                        dist[i][j][t + 1] = cost
                        heapq.heappush(pq, (cost, i, j, t + 1))
                    p += 1
                ptr[t + 1] = p
        return -1
