from typing import List
from functools import lru_cache
import math

class Solution:
    def maxProfit(
        self,
        n: int,
        present: List[int],
        future: List[int],
        hierarchy: List[List[int]],
        budget: int
    ) -> int:
        tree = [[] for _ in range(n)]
        for u, v in hierarchy:
            tree[u - 1].append(v - 1)
        def merge(a, b):
            res = [-math.inf] * (budget + 1)
            for i in range(budget + 1):
                if a[i] == -math.inf:
                    continue
                for j in range(budget - i + 1):
                    if b[j] == -math.inf:
                        continue
                    res[i + j] = max(res[i + j], a[i] + b[j])
            return res
        @lru_cache(None)
        def dfs(u: int, parentBought: bool):
            # Option 1: do NOT buy u
            dp_not = [0] + [-math.inf] * budget
            for v in tree[u]:
                child_dp = dfs(v, False)
                dp_not = merge(dp_not, child_dp)
            cost = present[u] // 2 if parentBought else present[u]
            profit = future[u] - cost
            dp_buy = [-math.inf] * (budget + 1)
            if cost <= budget:
                dp_buy[cost] = profit
                for v in tree[u]:
                    child_dp = dfs(v, True)
                    dp_buy = merge(dp_buy, child_dp)
            return [max(dp_not[i], dp_buy[i]) for i in range(budget + 1)]
        return max(dfs(0, False))
